#+title:     Rename me
#+author:    Logan Barnett
#+email:     logustus@gmail.com
#+date:      <2024-03-03 Sun>
#+language:  en
#+file_tags:
#+tags:

* Building the Actual Derivation/Flake

If you've been following along in the series, at this point I've got my
physical, standalone machine ready for generating machine learning images.  In
this segment, my plan is to make a derivation or flake (probably a flake) which
handles standing up the server (server being the application, and host being the
computer).

** The Plan

My overall goals look like this:

1. Configuration is entirely controlled via the Nix flake.
2. Models, LoRAs, and other large entities I want to create a kind of download
   function for.  So whether you're pulling these from http://civitai.com or
   https://huggingface.com, you can just declare the things you want installed
   and Nix will see to that.
3. New settings changes will send the appropriate signal to the web application
   so they can be reloaded.  Restarts can be "scheduled" if the queue is
   running.
4. This is more of a stretch goal, but it would be really cool to have a Nix
   declaration for an image.  So you say what the prompt is, what settings it
   should have, the seed, the model, etc. and the result is an image that you
   can throw around to other Nix plumbing, or just have on disk.

** Actually I can't do any of that yet

Of course nothing ever just works when you're the one trail blazing.  In this
case, I immediately ran into issues with =stable-diffusion-webui= just trying to
run it via the =automatic1111-webui-nix= repository.

*** Running stable-diffusion-webui via Nix

[2024-03-03 Sun]

#+begin_example
RuntimeError: Torch is not able to use GPU; add --skip-torch-cuda-test to
COMMANDLINE_ARGS variable to disable this check
#+end_example


#+begin_example
[logan@lithium:~/stable-diffusion-webui]$ nvidia-smi
Failed to initialize NVML: Driver/library version mismatch
NVML library version: 550.54
#+end_example

I'm told a reboot is needed from [[https://stackoverflow.com/questions/43022843/nvidia-nvml-driver-library-version-mismatch][here]].  It can be done without a reboot, but I'm
tired of being fancy.

Now I get:

#+begin_example
[logan@lithium:~/stable-diffusion-webui]$ nvidia-smi
Mon Mar  4 01:20:32 2024
+-----------------------------------------------------------------------------------------+
| NVIDIA-SMI 550.54.14              Driver Version: 550.54.14      CUDA Version: 12.4     |
|-----------------------------------------+------------------------+----------------------+
| GPU  Name                 Persistence-M | Bus-Id          Disp.A | Volatile Uncorr. ECC |
| Fan  Temp   Perf          Pwr:Usage/Cap |           Memory-Usage | GPU-Util  Compute M. |
|                                         |                        |               MIG M. |
|=========================================+========================+======================|
|   0  NVIDIA GeForce GTX 1060 6GB    Off |   00000000:01:00.0 Off |                  N/A |
| 28%   28C    P8             10W /  120W |       2MiB /   6144MiB |      0%      Default |
|                                         |                        |                  N/A |
+-----------------------------------------+------------------------+----------------------+

+-----------------------------------------------------------------------------------------+
| Processes:                                                                              |
|  GPU   GI   CI        PID   Type   Process name                              GPU Memory |
|        ID   ID                                                               Usage      |
|=========================================================================================|
|  No running processes found                                                             |
+-----------------------------------------------------------------------------------------+
#+end_example

 ./webui.sh --disable-model-loading-ram-optimization --lowvram --listen --api


 From all of this I was able to get =stable-diffusion-webui= up and going.  Now
 the fun part starts!  Converting all of this to an operationalized Nix
 configuration.

** Operationalizing automatic111-webui-nix

One of the really big things I want to see with this is being able to do this:

#+begin_src nix :results none
services.stable-diffusion-webui.enable = true;
#+end_src

And that starts up the =systemd= unit/service for =stable-diffusion-webui=.  I
expect before I can call that feature complete, I'll have to allow running the
startup script with various arguments.  I expect that to look something like
this:

#+begin_src nix :results none
services.stable-diffusion-webui = {
  enable = true;
  options.video-ram = "low"; # Equivalent of --lowvram.
  options.enable-api = true; # Equivalent of --api.
  options.allow-external-requests = true; # Equivalent of --listen.
  # A release valve to future-proof us.
  options.extra-options = [
    "--future-arg"
    "--future-arg-with-value foo"
  ];
};
#+end_src

I don't expect to enumerate all of the arguments, especially with
=extra-options= in place.

I start by creating a [[https://github.com/LoganBarnett/automatic1111-webui-nix][fork]] of [[https://github.com/virchau13/automatic1111-webui-nix][automatic1111-webui-nix]] as a starting point, and
hope to contribute the changes back.  I create a new branch
=operationalize-for-nixos=.  This is pretty basic so I won't cover it further.

Based on what I've seen from other tweaks and such that I've been making to a
NixOS =configuration.nix=, I expect I'll need create a "NixOS Module" - perhaps
as something that goes in =imports=.  I look for documents on the topic.  This
[[https://nixos.wiki/wiki/Extend_NixOS][Extend NixOS]] document looks like the perfect fit:

#+begin_quote
This tutorial shows how to extend a NixOS configuration to include custom
systemd units, by creating a systemd unit that initializes IRC client every time
a system session starts. Beginning by adding functionality directly to a
configuration.nix file, it then shows how to abstract the functionality into a
separate NixOS module.
#+end_quote

Yeah, I like that.  Adlib "IRC" for =stable-diffusion-webui= and this is exactly
what I'm looking for.

#+begin_quote
This article assumes some familiarity with systemd, and NixOs options. The
following links will be helpful for providing this background:
#+end_quote

I do have a basic familiarity with =systemd=.  I've started, stopped, and
restarted many-a-=systemd=-service in my time.  I've also peeked at the unit
files here and there, but I've never authored one to my recollection.  Still, I
haven't seen a lot in there that looked challenging or bespoke.  I've also
dabbled a little bit with "options" in Nix, but I haven't dealt with "NixOS
Options" that I know of, if that's even different than the general =mkOption=
and =mkConfig= stuff.  Unfortunately the link to "NixOS Options" is broken.  I
search the Wiki itself, and find [[https://nixos.wiki/wiki/NixOS:config_argument][NixOS:config argument]] as promising candidate.
This might be a good place to suggest or create an edit.

I skim the document.  It has this example (as a final, ideal example), which I
find perplexing:

#+begin_src nix
{config, pkgs, ...}:

let
  cfg = config.foo.bar.baz;

  # ...
in

with pkgs.lib; {
  options = {
    foo.bar.baz = {
      enable = mkOption { /* ... */ };
      option1 = mkOption { /* ... */ };
      option2 = mkOption { /* ... */ };
      option3 = mkOption { /* ... */ };
    };
  };

  config = mkIf cfg.enable {
    # ...
  };
}
#+end_src

With this explanation:

#+begin_quote
Often, the module declare options embedded inside an attribute set. To access
these options, we add an attribute cfg as a shortcut notation.
#+end_quote

In the =let=, how does =config.foo.bar.baz= not fail?  When did the attributes
get set there?  Is there some kind of magic going on with =options= or =config=
below?  What sort of pains are we avoiding if we _didn't_ use the =cfg =
config.foo.bar.baz;= statement?  I suppose I will find out.

I suppose the only way I can confirm some of this is to follow along in the
prior document.

This is how it starts:

#+begin_quote
NixOS provides a systemd module with a wide variety of configuration options. A
small number of those (which you can check out on NixOS search ) allows us to
implement this little snippet within our configuration.nix:
#+end_quote

#+begin_src nix :results none
# pkgs is used to fetch screen & irssi.
{pkgs, ...}:
{
  # ircSession is the name of the new service we'll be creating
  systemd.services.ircSession = {
     # this service is "wanted by" (see systemd man pages, or other tutorials) the system
     # level that allows multiple users to login and interact with the machine non-graphically
     # (see the Red Hat tutorial or Arch Linux Wiki for more information on what each target means)
     # this is the "node" in the systemd dependency graph that will run the service
     wantedBy = [ "multi-user.target" ];
     # systemd service unit declarations involve specifying dependencies and order of execution
     # of systemd nodes; here we are saying that we want our service to start after the network has
     # set up (as our IRC client needs to relay over the network)
     after = [ "network.target" ];
     description = "Start the irc client of username.";
     serviceConfig = {
       # see systemd man pages for more information on the various options for "Type": "notify"
       # specifies that this is a service that waits for notification from its predecessor (declared in
       # `after=`) before starting
       Type = "notify";
       # username that systemd will look for; if it exists, it will start a service associated with that user
       User = "username";
       # the command to execute when the service starts up
       ExecStart = ''${pkgs.screen}/bin/screen -dmS irc ${pkgs.irssi}/bin/irssi'';
       # and the command to execute
       ExecStop = ''${pkgs.screen}/bin/screen -S irc -X quit'';
     };
  };

  environment.systemPackages = [ pkgs.screen ];

  # ... usual configuration ...
}
#+end_src

Very good!  This is great documentation, because I have something that tells me
what virtually every line here is doing.  As a nitpick, the
=environment.systemPackages= line could use some explanation, but I'm familiar
enough with Nix to know that this is the =systemPackages= for _this_ module and
it'll get mushed together with other, included =systemPackages= from other
modules later.

To take my stab at it:

#+begin_src nix :results none
# pkgs is used to fetch screen & irssi.
{pkgs, ...}:
{
  # stable-diffusion-webui is the name of the new service we'll be creating
  systemd.services.stable-diffusion-webui = {
    # This service is "wanted by" (see systemd man pages, or other tutorials)
    # the system level that allows multiple users to login and interact with
    # the machine non-graphically (see the Red Hat tutorial or Arch Linux Wiki
    # for more information on what each target means) this is the "node" in the
    # systemd dependency graph that will run the service.
    wantedBy = [ "multi-user.target" ];
    # The systemd service unit declarations involve specifying dependencies and
    # order of execution of systemd nodes; here we are saying that we want our
    # service to start after the network has set up.
    after = [ "network.target" ];
    description = "A machine learning image generator using Stable Diffusion.";
    serviceConfig = {
      # See systemd man pages for more information on the various options for
      # "Type": "notify" specifies that this is a service that waits for
      # notification from its predecessor (declared in `after=`) before
      # starting.
      Type = "notify";
      # The username that systemd will look for; if it exists, it will start a
      # service associated with that user.
      User = "username";
      # The command to execute when the service starts up.
      ExecStart =
        ''${pkgs.stable-diffusion-webui}/webui.sh'';
      # The command to execute.
      # ExecStop = ''${pkgs.screen}/bin/screen -S irc -X quit'';
      KillSignal = "SIGINT";
      Restart = "always";
      RestartSec = "15s";
    };
  };
  environment.systemPackages = [ ./stable-diffusion-webui.nix ];
}
#+end_src

This is a draft, of course.  I want some arguments to pass it.  For now, I want
to make this work.  I don't have a =./stable-diffusion-webui.nix= package to
refer to, but I'd like to try that now.  As I start to look at this, I'm seeing
the big chain of =if/else= in the =impl.nix= used in =automatic111-webui-nix=.
I think the best thing to do here actually is just build separate packages for
each of the "modes".  This is the code as it is today:

#+begin_src nix :results none
{ pkgs, variant, ... }:

let
  hardware_deps = with pkgs;
    if variant == "CUDA" then [
      cudatoolkit
      linuxPackages.nvidia_x11
      xorg.libXi
      xorg.libXmu
      freeglut
      xorg.libXext
      xorg.libX11
      xorg.libXv
      xorg.libXrandr
      zlib

      # for xformers
      gcc
    ] else if variant == "ROCM" then [
      rocmPackages.rocm-runtime
      pciutils
    ] else if variant == "CPU" then [
    ] else throw "You need to specify which variant you want: CPU, ROCm, or CUDA.";

in
pkgs.mkShell rec {
    name = "stable-diffusion-webui";
    buildInputs = with pkgs;
      hardware_deps ++ [
        git # The program instantly crashes if git is not present, even if everything is already downloaded
        python310
        stdenv.cc.cc.lib
        stdenv.cc
        ncurses5
        binutils
        gitRepo gnupg autoconf curl
        procps gnumake util-linux m4 gperf unzip
        libGLU libGL
        glib
      ];
    LD_LIBRARY_PATH = pkgs.lib.makeLibraryPath buildInputs;
    CUDA_PATH = pkgs.lib.optionalString (variant == "CUDA") pkgs.cudatoolkit;
    EXTRA_LDFLAGS = pkgs.lib.optionalString (variant == "CUDA") "-L${pkgs.linuxPackages.nvidia_x11}/lib";
}
#+end_src

I'm going copy, mostly verbatim, what I see in =mkShell= into this package.  I'm
not using the =with pkags;=, because I believe that is an anti-pattern in most
cases (including this one).  I'm also going to grammarize, punctuate, and fill
to 80 columns any comments I want to preserve.  Packages will be sorted, since
their order is irrelevant and trying to "group" things leads to sadness when
code comments would have sufficed.  This is kind of my standard treatment on
anything I touch.  My preference would've been to comment on each of the
dependencies, explaining why they are needed and a brief description of what
they are.  For example, I know why =git= is needed, because there is a comment
for it.  I don't know what =m4= is or why is it is needed.  For all I know, it's
vestigial.

#+begin_src nix :results none
##
# This is the base derivation where all shared dependencies, settings, and code
# exist.
{ pkgs, ... }: {
  name = "stable-diffusion-webui";
  buildInputs = [
    pkgs.autoconf
    pkgs.binutils
    pkgs.curl
    # The program instantly crashes if git is not present, even if everything is
    # already downloaded.
    pkgs.git
    pkgs.gitRepo
    pkgs.glib
    pkgs.gnumake
    pkgs.gnupg
    pkgs.gperf
    pkgs.libGL
    pkgs.libGLU
    pkgs.m4
    pkgs.ncurses5
    pkgs.procps
    pkgs.python310
    pkgs.stdenv.cc
    pkgs.stdenv.cc.cc.lib
    pkgs.unzip
    pkgs.util-linux
  ];

  LD_LIBRARY_PATH = pkgs.lib.makeLibraryPath buildInputs;
  # Actually, these need to get moved to specialized derivations.
  # CUDA_PATH = pkgs.lib.optionalString (variant == "CUDA") pkgs.cudatoolkit;
  # EXTRA_LDFLAGS = pkgs.lib.optionalString (variant == "CUDA")
  #   "-L${pkgs.linuxPackages.nvidia_x11}/lib";
}
#+end_src

Okay that's a start.  When we run =webui.sh=, it installs a bunch of packages
via =pip=.  That's not the Nix Way™.  Instead we can use some fancy tools to
convert =requirements.txt= and its friends into Nix expressions that are totally
reproducible.  =pip2nix= looks good enough.  Being under =nix-community= is high
praise in my eyes.

I modify the =inputs= section to have a =pip2nix= section:

#+begin_src nix :results none
inputs = {
    nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable;
    flake-utils.url = github:numtide/flake-utils;
    pip2nix = {
        url = github:nix-community/pip2nix;
        inputs.nixpkgs.follows = "nixpkgs";
    };
};
#+end_src

I had to do the URL over about three times to get it right, because I just
dropped the URL in from my browser.  Derp.  The =unrecognized archive format= I
have learned usually means I have =github.com= instead of =github=.

And then make it available in the shell.  Actually, I forgot this flake is a bit
weird.  I understand the author just wanted to get something up and running.
Our goal here is to make it "proper".  This is what we start with:

#+begin_src nix :results none
devShells.default = throw "You need to specify which output you want: CPU, ROCm, or CUDA.";
devShells.cpu = import ./impl.nix { inherit pkgs; variant = "CPU"; };
devShells.cuda = import ./impl.nix { inherit pkgs; variant = "CUDA"; };
devShells.rocm = import ./impl.nix { inherit pkgs; variant = "ROCM"; };
#+end_src

Which is really not something we want.  I want the =devShells= to be the real deal.
I also understand why the author went with =flake-utils=, and at one point I
would've agreed.  Though it's got (IMO) poor documentation when I recently
looked at it, and to reap its benefits you'd need to know how to combine or
specialize configurations that differ due to different platforms, but that's
neigh impossible to sort out without digging into the code.  I'd rather just
specify platforms supported, and then add new ones as we figure out how to
support them (be it via automated tests or we find +suckers+ volunteers to
represent the various platforms).

So I'm scrapping basically everything in the =outputs= section.  Now we have:

#+begin_src nix :results none
outputs = { self, nixpkgs, pip2nix }: {
  devShells.aarch64-darwin.default = {
    packages = [
      # So we can generate requirements.nix from requirements.txt.
      pip2nix
    ];
  };
};
#+end_src

Also at this point, I just redo all of the formatting to 2 spaces, which I think
is the Nix standard (and for an 80 column addict, a must).  With that in place:

#+begin_src nix :results none
{
  description = "AUTOMATIC1111/stable-diffusion-webui flake";

  inputs = {
    nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable;
    pip2nix = {
      url = github:nix-community/pip2nix;
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, pip2nix }: {
    devShells.aarch64-darwin.default = { ... }: let
      pkgs = import nixpkgs {
        system = "aarch64-darwin";
      };
    in {
      packages = [
        # So we can generate requirements.nix from requirements.txt.
        pkgs.pip2nix
      ];
    };
  };
}
#+end_src

And then I try it out:

Actually I flail for a moment, and then arrive at:

#+begin_src nix :results none
{
  description = "AUTOMATIC1111/stable-diffusion-webui flake";

  inputs = {
    nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable;
    pip2nix = {
      url = github:nix-community/pip2nix;
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, pip2nix }: {
    devShells.aarch64-darwin.default =  let
      pkgs = import nixpkgs {
        system = "aarch64-darwin";
      };
    in pkgs.mkShell ({ ... }: {
      packages = [
        # So we can generate requirements.nix from requirements.txt.
        pip2nix
      ];
    }
    );
  };
}
#+end_src

-----

[2024-03-05 Tue]

I went down a rabbit hole trying to get =pip2nix= going so I could convert the
=requirements.txt= into Nix expressions.  I learned a bit about Flakes more, and
also learned to distrust/dislike =flake-utils= and =flake-parts= more
(especially =flake-utils=, which seems to lack a lot of helpful documentation).
I came across [[https://discourse.nixos.org/t/mach-nix-pip2nix-poetry2nix-or-pynixify-for-zulip-provision/18836/20][Mach-nix, pip2nix, poetry2nix, or pynixify for Zulip provision]]
which does a lot of work breaking down the various options out there.  I learned
from reading it that =poetry= is a dependency management tool for Python which
uses =pip= under the hood.  So just because there's a =requirements.txt= doesn't
necessarily mean the project is truly governed by =pip=.  The giveaway is
=pyproject.toml= - =peotry='s file.  Sure enough, =stable-diffusion-webui= has a
=pyproject.toml= file.  Ugh.  Day wasted sort of.  I've learned a lot, but I'd
really like to just gain some progress instead and save some learning for later.
I'm going to have a PhD in Nix soon!

TODO: Explain where I used this: https://discourse.nixos.org/t/debugging-a-flake/14898

Front and center, =peotry2nix= has:

#+begin_quote
poetry2nix turns Poetry projects into Nix derivations without the need to
actually write Nix expressions. It does so by parsing pyproject.toml and
poetry.lock and converting them to Nix derivations on the fly.
#+end_quote

Exactly what I want!  They wrote some documentation too!  I read the docs.
There's a list of functions with a brief summary as to what they do.  I skimmed
them to make sure I have some awareness of what's available to me, but my eyes
locked on =mkPoetryAppliction= early.  Later the documentation provides a
description of the function.  Brilliant!

#+begin_quote
mkPoetryApplication

Creates a Python application using the Python interpreter specified based on the
designated poetry project and lock files. mkPoetryApplication takes an attribute
set with the following attributes (attributes without default are mandatory):

...
#+end_quote

Just taking a second here.  Feel like you are bad at writing documentation?
Feel like it's so much work?  Do you think this was a lot of work?  This prose
is fairly direct.  But if it were wordy and full of edge cases (which is
arguably not great for the first paragraph), that would've been fine too.  I'd
rather get way too much information and have to sift through it than none at
all.

Okay back to this endeavor.

If I can bundle =stable-diffusion-webui= as a "program" then I should be able to
run it from =ExecStart= in the =systemd= unit file (which NixOS apparently
handles for me).  Are we really that close?  No way.  There must be peril around
the corner.

https://github.com/nix-community/poetry2nix/issues/1457

Ugh, I misspelled =mkPoetryApplicatgion= as =mkPythonApplication=.  Hard to make
examples work when the identifiers aren't right.  The issue above isn't even
relevant.

#+begin_src nix :results none
{
  description = "AUTOMATIC1111/stable-diffusion-webui flake";

  inputs = {
    nixpkgs.url = github:NixOS/nixpkgs/nixos-unstable;
    poetry2nix = {
      url = "github:nix-community/poetry2nix";
      inputs.nixpkgs.follows = "nixpkgs";
    };
  };

  outputs = { self, nixpkgs, poetry2nix }: {
    devShells.aarch64-darwin.default =  let
      system = "aarch64-darwin";
      pkgs = import nixpkgs {
        inherit system;
        overlays = [
        ];
      };

    in pkgs.mkShell {
      packages = [];
    };
    packages.aarch64-darwin.default = let
      system = "aarch64-darwin";
      pkgs = import nixpkgs {
        inherit system;
      };
      inherit
        (poetry2nix.lib.mkPoetry2Nix { inherit pkgs; })
        mkPoetryApplication
      ;
    in
      mkPoetryApplication {
        projectDir = pkgs.fetchFromGitHub {
          owner = "AUTOMATIC1111";
          repo = "stable-diffusion-webui";
          rev = "v1.8.0";
          hash = "sha256-HsHFY2OHgGC/WtZH8Is+xGbQUkcM1mhOSVZkJEz/t0k=";
        };
      };
  };
}
#+end_src


#+begin_example
       error: getting status of '/nix/store/mr0n59p7yp1wgsi0qr5qdmhdraa0ccrn-source/poetry.lock': No such file or directory
#+end_example


------

[2024-03-09 Sat]

Time has gotten away from me.  I haven't been able to keep this as updated as I
would've liked.  I have been working on this every day since my last update -
some days progress is made, others... nothing.

Some things I recall from memory:

1. =poetry= is not being used here.  In fact, all that is used is =pip=.
2. Many Python packages have broken tests - at least within the Nix ecosystem.
3. Some of the Python packages involved with this endeavor lack tagged releases,
   and even _commits_ are missing for the releases.
4. =tzdata= is [[https://github.com/NixOS/nixpkgs/pull/292480][broken]], but it hasn't moved to =nixpkgs-unstable= because somehow
   it's [[https://github.com/NixOS/nixpkgs/pull/292480#issuecomment-1972722709][better that way]]?   This is beyond me.
5. Now I'm seeing build failures from =pixman= due to tests timing out.  I have
   not seen a ticket about this yet.
6. I think the =tzdata= fix is now in =nixpkgs-unstable=, which I'm trying a
   build for again.  These package updates are so incredibly fundamental but
   I'm doing hour-long builds trying to get all of the packages built - and for
   whatever reason there's no cache hits I get to enjoy.


None of the "high level" package managers for Python.  I have learned there are
many, and there seems to be some convergence happening with =pyproject.toml=,
which is a sort of funnel that gathers all of various package managers into one,
standardized file.  Each package manager has its own settings in this file
though, so it's very much a baby step on standardizing package management in the
Python ecosystem.

These problems are so frequent that Nix's Python builders have =disabledTests=
and =disabledTestFiles= as properties, where one can list tests by names or test
files in order to exclude them.  Some of this is because tests are not
hermetic - meaning they make HTTP calls to some service external to everything,
or they reach outside of the allocated area in the Nix store.  The other is that
the tests are legitimately broken.  I've also seen a lot of instances where
various tests time out.  I believe this is because my machine is running many
builds in parallel (Nix's doing, not mine).  I can observe all cores used during
the build.  My theory is that this high utilization is making the individual
tests run slowly.

-----

While I've been playing whack-a-mole with what feels like the entire Python
ecosystem, I did some thinking - this is actually a performance critical
application.  I need speed and memory.  I don't know if it's all on the GPU or
not, but I suspect it isn't.  If it isn't, it's got me thinking that having all
of this machine learning tech sitting on a Python stack probably isn't the best,
even if much of it is deferred to the GPU and natively compiled libraries.

From that line of thinking, I quickly came across [[https://github.com/vv9k/AIrtifex][AIrtifex]].  It covers more than
just image generation, which is my ultimate goal.  That said, there's not a lot
of users on this so I would very much be beta testing things in a sense.  Though
arguably by doing this via Nix, I would be doing that already.  I suspect the
intersection with Nix and Rust is a more pleasant one than I've encountered with
the likes of Python in this endeavor and Ruby in my workplace.  I suspect that I
will need to learn a lot more direct things about machine learning generation in
order to use AIrtifex, but that isn't necessarily a bad thing.  Since these
builds take so immensely long, I'm tempted to spin off a separate branch of work
just to try to see if I can make it happen.

These long builds, heavy downloads, and heavy amounts of disk have me thinking
about setting up some builders and substitutors.

-----

[2024-03-22 Fri]

It's been three weeks.  Three weeks where I've worked every day on this without
fail, for at least a couple of hours every day.  I've been chasing all kinds of
threads trying to get things working.  I've done a bad job journaling the
process, but here's what I recount:

AIrtifex was a bust.  I couldn't figure out what magic version to use for Rust
itself.  Rust's evolving syntax has made them embrace a sort of macro/feature
flag suite that allows folks on "nightly" (read: everyone) to use the latest and
greatest stuff.  The problem is that it's really hard to tell which minimum
version is needed.  Also, these bleeding edge language and toolchain features
are disabled once the features are pulled into the stable release line.  This
makes for both a maximum and _minimum_ window in which particular piece of
latest-and-greatest features can work.

=fenix= just seems to track nightly, which is a little weird because it doesn't
seem to be good at tracking an arbitrary version or even a dated version.  It
seems to be touted as the best plugin for the job, but I haven't found that to
be the case, despite having used it before.  I found <insert version> to be
ideal here.

In order to better share my work I've been doing, I've moved my Nix setup for my
various hosts on my network and/or possession into my public dotfiles
repository.  I'll be updating links in my old posts accordingly.  This has also
allowed me to get significant reuse.

I switched to ComfyUI and found a pull request out by zaro06.  It got pretty
flooded with feedback and the author was overwhelmed to the point of just
stepping away from the pull request, which I absolutely cannot fault them for.
I don't know that I can fault the reviewers either, but I will admit I have seen
this a lot and feel that ultimately the barriers we make to contributions
actually hurt open source, even if it is done to spare the maintainers (and
important goal).  I feel there is another, better answer out there, but I'm not
in the position to sort it out right now.

I had a lot of trouble trying to get =torch= et. al. to build.  These were some
=invalid memory reference= errors.  I thought this might be a regression with
the pin I bent back, even though it passed a memory test.  I have come to find
out that my NixOS installer no longer boots.  I have tried using different
drives.  I might have a USB port issue, but I somehow doubt it.  Either way, I
did another memory test and was satisfied with the results.

I was able to finally come across this post in Discourse which basically laid
out the current state of all things =torch=, =CUDA=, etc.  This was the trove I
was looking for.  It was something I found via a link in another post.  From
this I was able to get a working build of =ComfyUI=, even if it wasn't ready to
actually use yet.

I think the fact that this is just a post somewhere and not part of the
documentation speaks greatly to the curse of Nix.  Documentation allergies seem
to be everywhere - although it's at least _something_.  Perhaps I can help
migrate this to some official documentation.

I've done a lot of work for Nix so far.  I've shared everything I could here,
and that's not great documentation either, but it's not nothing.  It's also a
substantial amount of work for me.  I have also publicly stated I will be
helping with the requests made on the pull request for ComfyUI.  All in all,
I'll be a major Nix contributor soon, even though that wasn't really what I'd
set out to do.

** Operationalizing ComfyUI

[2024-03-23 Sat]

It didn't take long for me to get some things up and going - ComfyUI now listens
on =0.0.0.0= for me.  The port it uses on the firewall is open.  I even got a
primitive form of downloading working for the various kinds of models.  It took
me a bit to realize that with no extensions, ComfyUI cannot find the models.  So
I need a better linking and/or declaration mechanism.

I've loaded SDXL models, which actually fit on my video card.  The
manually-installed version I had of =stable-diffusion-webui= on the same host
couldn't fit it.  This was one of the reasons I decided to try ComfyUI, so I'm
really glad to see it made a difference too.

This interface is far more difficult than =stable-diffusion-webui=, but I think
during this whole journey, I've done myself a disservice by not RTFMing first.
I would like to just read the documentation on Stable Diffusion, so I better
understand what latent space is, denoising, and some of the other terms that get
tossed around.

I almost want ComfyUI to use code instead of being graphical.  Something like
Verilog or VHDL comes to mind.  I could even use... Nix!  Certainly, after
putzing around and losing settings very easily, and having to click, drag, and
sometimes do the multi-finger allioop on a touch pad really will have me sick of
this interface soon, even if it does offer immense power.



* COMMENT settings
#  LocalWords:  AIrtifex
