#+BEGIN_EXPORT html
---
layout: default
title: Software Engineering - Starter Web app
date: 2018-06-13
categories: software-engineering
---
#+END_EXPORT

#+title:    Software Engineering - Starter Web app
#+author:   Logan Barnett
#+email:    logustus@gmail.com
#+date:     <2018-06-13 Wed>
#+language: en
#+tags:     tutorials software web

The purpose here is to go over some basic web stuff and get a server up and
running, with maybe a web interface.

* legend
** terminal commands
  A source block with a =$= in front generally means this is a command you
  should run as your normal user from within a terminal or shell. Commands on
  your system are programs, and you should either only run commands you
  understand and/or originate from a trusted (by you) source. If the command is
  prefixed with a =#= it means to run the command with elevated permissions,
  such as the =root= user or as a =sudoer= using =sudo=. Generally commands that
  want elevated permissions should be treated with greater scrutiny.

  #+begin_src shell
  $ ls -al
  #+end_src

  This means copy =ls -al= and paste it into your terminal (on MacOS,
  =Terminal.app= works just fine for this). Then press enter. You should see
  some output from the command, or a lack of error. Sometimes seeing it do
  nothing is okay. Once the command is complete, you'll see the prompt displayed
  again (usually ending with =$=) which means the shell is ready for the next
  command.

  Some instructions will also omit the =$= entirely but provide some context
  that this is a command you should be running. Usually this means you run the
  command the same way you would as =$=, and NOT =#= (root).

  Sometimes you'll see what seems to be both =$= and not =$= in the same block.
  Generally this means that the =$= is the command you run, and the text that
  follows that isn't preceded by a =$= is the _output_ of the command(s).

  For example:

  #+begin_src shell
  $ ls
  foo bar baz
  #+end_src

  Here we're running =ls= and, as a contrived example, we're seeing it print
  =foo bar baz= as its output.

** shell

   A terminal is a window that runs a shell. A shell is a program that lets you
   input commands and you can see the results. A _good_ shell can provide lots
   of assistance in putting together commands, and has a means of composition of
   those commands. Composition is something we'll get more into later. The
   commands themselves are too many to enumerate, and learning them is a place
   where you can spend indefinite amounts of time mastering. Focus on learning
   parts of the shell only a little bit at a time.

* tools
  We'll need some tools installed to ease this along.
** system software
*** homebrew
   [[https://brew.sh][Homebrew]] is needed to install some basic stuff. Follow the link and follow
   it's instructions. See the [[shell]] and [[terminal commands]] section for learning
   how to install Homebrew.

   Once you have that, we'll want to install Homebrew's =cask= system, which
   allows us to install apps (which can be considered to be a little different
   from commands and utilities). We'll want to use cask later in your system
   setup, so let's install it now:

   #+begin_src shell
   brew tap caskroom/cask
   #+end_src

*** Node.js
    Once Homebrew is installed, we can install a recent version of Node.JS, which
    we'll need for running a server. The version we install isn't terribly
    important right now. Run this command to install Node:

    #+begin_src shell
    brew install node
    #+end_src

*** yarn
    =yarn= is a replacement for =npm=. You don't need to know =npm= but
    understand there is a lot of legacy projects out there with their install
    instructions using =npm=. For the most part, any place you see =npm= you can
    substitute with =yarn= and the command will work fine. One notable exception
    is that =npm install <package>= maps to =yarn add <package>=. Here,
    =<package>= refers to the name of a package without the angle braces (=<>=).
    A package named =foo= would be installed with =yarn add foo=.

    Install =yarn= with Homebrew using this command:
    #+begin_src shell
    $ brew install yarn
    #+end_src

*** git
    =git= is a version control system. It's a vital tool for software
    development as it performs incremental backups of your source code. It
    provides a rich history (provided you leave messages for yourself) and
    allows you to easily share your code with others.

    I don't recall if MacOS has a version pre-installed, but I do know that with
    Homebrew we can ensure we're using it and also be on the latest version:

    #+begin_src shell
    brew install git
    #+end_src

** editor
   [[https://atom.io][Atom]] is a plenty good starter editor. It's basic. It's a pretty Notepad with
   plugins and indentation. For now, this is fine.

   You can install Atom via homebrew as well!

   #+begin_src shell
   brew cask install atom
   #+end_src

   Once this is done, you can run Atom from your terminal using the =atom=
   command, or run it as an application from the =/Applications= directory. You
   can also open Spotlight by pressing Command-Space and typing "atom" without
   the quotes.
* your development directory
  Your development directory is a place where you can throw all of your software
  projects. It seems like everyone has their own convention and no two are
  alike. You can't really get this wrong, but generally you might be typing it a
  bit so keeping it short and sweet is nice. For this doc we're going to use
  =dev= but really you can use anything you like so long as you can remember it
  easily.

  #+begin_src shell
  mkdir dev
  #+end_src

  =mkdir= creates the =dev= directory. Now we'll enter the directory. =mkdir= is
  a program that will only print something if something goes wrong, so if it
  looks like nothing happened, that's okay. No news is good news.

  #+begin_src shell
  cd dev
  #+end_src

  After running this, you should see =dev= in your shell's prompt.
* take a break
  Good job! Let's take a minute to look around and not see a screw for a few
  minutes.

* setting up your project
  Let's make sure your terminal is in your development directory.

  #+begin_src shell
  $ pwd
  /Users/logan/dev
  #+end_src

  Let's make a directory for our project. This project will be about expressing
  our deep hatred of cats. Cats killed my parents, okay?

  #+begin_src shell
  mkdir cat-hate
  #+end_src

  And enter the directory:

  #+begin_src shell
  cd cat-hate
  #+end_src

  Now let's let =yarn= initialize our project:

  #+begin_src shell
  yarn init
  #+end_src

  It will prompt you with some questions. If you don't know a good answer, or
  are fine with its guess, you can use the default (which is the value in the
  parenthesis =()=). Enter default values by pressing enter.

  Let's also get =git= initialized.
  #+begin_src shell
  git init
  #+end_src

  We'll be running a Node server using a library called =express=. We can use
  =yarn= to install it.

  #+begin_src shell
  yarn add express
  #+end_src

* creating your first node app

  Now we're going to open our editor. We can open it with a file (or even a
  blank file that doesn't exist yet) by giving the =atom= command an argument.
  The argument is the name of the file we want to open or create. Let's name it
  =server.js=.

  #+begin_src shell
  atom server.js
  #+end_src

  We need to pull in =express=. In Node, we do that using =require=.

  Put this into your editor:

  #+name: express-require
  #+begin_src js
  const express = require('express')
  #+end_src

  =express= is a function that produces an "application" in their terms. Let's
  create that now.

  #+name: express-create-app
  #+begin_src js
  const app = express()
  #+end_src

  Now we'll construct an endpoint by listening to =GET= requests. We'll just
  listen to ones directed at the root of our webapp for now.

  #+name: express-get-handler
  #+begin_src js
  app.get('/', (req, res) => {
    res.send('ohai')
  })
  #+end_src

  There's a lot going on there, even for a very simple response handler. We'll
  go over that in a bit, but let's get it so we can run the server first, and
  then test that it works.

  #+name: express-listen
  #+begin_src js
  app.listen(3000, () => console.log('Example app listening on port 3000!'))
  #+end_src

  Okay, so all together this is what it should look like:

  #+begin_src js :noweb yes
  <<express-require>>

  <<express-create-app>>

  <<express-get-handler>>

  <<express-listen>>
  #+end_src

  Let's run the app:

  #+begin_src shell
  $ node server.js
  Example app listening on port 3000!
  #+end_src

  Now let's make a new tab (Command-T on MacOS). You might have to =cd= back to
  your project directory:

  #+begin_src shell
  cd ~/dev/cat-hate
  #+end_src

  Now we'll test that it works with =curl=, a powerful tool for using and
  debugging HTTP requests.

  #+begin_src shell
  $ curl http://localhost:3000
  ohai
  #+end_src
