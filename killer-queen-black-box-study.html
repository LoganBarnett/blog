---
layout: default
title: Killer Queen Black Box Study
date: 2018-01-14
categories: killer-queen
---

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org63c1bcd">1. introduction</a></li>
<li><a href="#orgcd395a3">2. background</a></li>
<li><a href="#org52dc8ec">3. reasoning</a></li>
<li><a href="#org7afd1f7">4. things</a>
<ul>
<li><a href="#orgbaa376d">4.1. frames</a>
<ul>
<li><a href="#org5d83af9">4.1.1. history</a></li>
<li><a href="#orga45780e">4.1.2. complications</a></li>
<li><a href="#org5c8557d">4.1.3. the operating system</a></li>
<li><a href="#org1042b3e">4.1.4. the solution</a></li>
<li><a href="#org9a34184">4.1.5. side by side</a></li>
<li><a href="#orga7f2857">4.1.6. conclusion</a></li>
</ul>
</li>
<li><a href="#orga89e505">4.2. pixels</a>
<ul>
<li><a href="#org34ae578">4.2.1. 2D as 3D</a></li>
<li><a href="#orgdf1bc1f">4.2.2. what about the pixel graphics?</a></li>
<li><a href="#org13f2af8">4.2.3. <span class="todo TODO">TODO</span> conclusion</a></li>
</ul>
</li>
<li><a href="#orgb633347">4.3. <span class="todo TODO">TODO</span> the wrap glitch</a></li>
<li><a href="#orgae40a0b">4.4. <span class="todo TODO">TODO</span> game stutter</a></li>
<li><a href="#org4e2ab6d">4.5. <span class="todo TODO">TODO</span> the "drip"</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org63c1bcd" class="outline-2">
<h2 id="org63c1bcd"><span class="section-number-2">1</span> introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
At the Portland scene we like to talk a lot about different things we've learned
about Killer Queen, and being that the game is effectively a hunk of software we
wind up talking a lot about details of its internal implementation. This post is
about the software implementation we know about Killer Queen or things we are
able to infer about said software. The source code for Killer Queen is locked in
a vault somewhere, guarded by a small army of the best speed warriors. As such
we can't say for 100% certainty about everything. The game is a black box where
we cannot see inside it. We can make some good guesses though.
</p>
</div>
</div>

<div id="outline-container-orgcd395a3" class="outline-2">
<h2 id="orgcd395a3"><span class="section-number-2">2</span> background</h2>
<div class="outline-text-2" id="text-2">
<p>
I (Logan Barnett AKA Day Logan) have done game development both professionally
and as a hobbyist for many years now, and I'm an accomplished software engineer.
At time of writing my current work is in web development, but I am comfortable
straddling both worlds. I used to pay my bills making an educational game in
Unity. Unity is the game engine that was used to build Killer Queen. My hobby
projects have taken my experience beyond the scope of that game. I have had
an opportunity to work with Unity's physics system (and work around it), use its
character controller system, networking, shaders, GUI (editor and in-game), and
its logic/behavior system. I also have an educational background in computer
engineering, so I have a good conceptual understanding of operating systems,
memory models, resource sharing, etc. My <a href="./resume.html">resume</a> is here for full transparency.
</p>
</div>
</div>

<div id="outline-container-org52dc8ec" class="outline-2">
<h2 id="org52dc8ec"><span class="section-number-2">3</span> reasoning</h2>
<div class="outline-text-2" id="text-3">
<p>
If you had to build a car, there's a lot of things you could say about building
a car without actually having to look at the blue prints. Cars need some way of
touching the ground (wheels). They need a drive train that pushes the car in the
direction we want to go. There needs to be some kind of steering apparatus (even
for self driving cars) so you can make sure the car is moving the direction you
want to go. We can do this with software too. In order to accomplish certain
things, there's just machinery that needs to be in place. Unity has a lot of
things built into it, and circumventing those built in things so you can do
something custom can mean a <span class="underline">lot</span> of work. Bumblebee Games doesn't have that
kind of resources.
</p>
</div>
</div>

<div id="outline-container-org7afd1f7" class="outline-2">
<h2 id="org7afd1f7"><span class="section-number-2">4</span> things</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgbaa376d" class="outline-3">
<h3 id="orgbaa376d"><span class="section-number-3">4.1</span> frames</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org5d83af9" class="outline-4">
<h4 id="org5d83af9"><span class="section-number-4">4.1.1</span> history</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
The first time I learned about "frames" was in talk about how Street Fighter 2
works. Keep in mind this game is ancient by today's standards. With the Street
Fighter 2 cabinet, the hardware there focused on exactly one thing: Running
Street Fighter 2. This meant the game could make some assumptions about its
operation, namely its timing. Street Fighter 2 plays at 30 frames per second,
meaning the screen redraws itself 30 times a second. Each cycle between the
redraw is a "frame". During this time, the game does all of its computations. It
copies pixels around, computes distances, does hit box checks, etc all in this
tight little loop. Since frames in Street Fighter 2 are fixed to this 30 times
per second, that means you have about 33 milliseconds to do all of your
computations. Any smarts that are in the game have to fit in this time period.
If that's the case, you can count on each frame being 33 milliseconds long, and
you can derive timing in the animation system, what your grace period is to
throw a fireball, or chain together some combo, or whatever. But the problem is
this is a lie. It's just an infrequent one for Street Fighter.
</p>

<p>
Remember Solitaire? That game that came built into Windows 3.x back when you had
to clean mouse balls? Yeah that one. I think it's still in Windows today. If you
beat Solitaire, you were given a wonderful little animation of the cards
cascading out of their slots, kind of undoing everything you just did. You could
easily go use the bathroom and come back to see it still going. This thing took
a while. At the time if you were on Windows 3.x and you had a 66 Mhz computer,
this would go pretty slow. Once you got a Pentium, you'd notice the animation
completed in about a second or two. In both situations, the game was doing the
animation as fast as possible, but one computer was significantly faster than
the other. Computers back then often had a turbo button. You could use this
button to slow your computer down and run older applications that had this kind
of timing problem. Street Fighter would be one of those applications.
</p>
</div>
</div>

<div id="outline-container-orga45780e" class="outline-4">
<h4 id="orga45780e"><span class="section-number-4">4.1.2</span> complications</h4>
<div class="outline-text-4" id="text-4-1-2">
<p>
The lie about frame counting is that sometimes the computations can't complete
in the time period they have. This happens a lot in Chun Li's level: There's so
many animations and other things going on that if the players add a little bit
more and maybe step away from each other, the hardware sudden has way too much
to do to cram into that 33 millisecond time slice, so it just takes longer, and
as a result the game enters a strange kind of slow motion.
</p>
</div>
</div>

<div id="outline-container-org5c8557d" class="outline-4">
<h4 id="org5c8557d"><span class="section-number-4">4.1.3</span> the operating system</h4>
<div class="outline-text-4" id="text-4-1-3">
<p>
Back in the day of Street Fighter 2, and most gaming consoles for that matter,
the game you were running was the program the hardware ran. Today even the XBox
and PSX consoles run an operating system (OS). When you boot up your mac and run
Photoshop or whatever, you're not running Photoshop. You're running MacOS. The
operating system is a very intricate program that makes it look like you're
running other programs. In reality the OS grants programs the ability to execute
a few instructions at a time before the OS interrupts and then gives another
program a chance to run on the processor. When it does a good job about
switching around really fast, it makes it look like you're running multiple
programs at once. Your games are one of these programs. This makes it really
hard to promise that you have exactly 33 milliseconds to complete your
operations. In the middle of the frame, the OS could easily have let several
dozen other programs run a little bit too, each eating into that precious slice
of time.
</p>

<p>
As an example, there's a small program running in this post that loops and
prints the time since the last tick in milliseconds. Notice the variance.
</p>

<div>Time since last tick: <span data-id="millisecond-monitor"></span></div>

<p>
Here's the code that does this, if you want to follow along:
</p>
<div class="org-src-container">
<pre class="src src-javascript" id="org7f5acc0"><span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">lastTime</span> = Date.now<span style="color: #4f97d7;">()</span>
<span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">el</span> = document.querySelector<span style="color: #4f97d7;">(</span><span style="color: #2d9574;">'[data-id="millisecond-monitor"]'</span><span style="color: #4f97d7;">)</span>
<span style="color: #4f97d7; font-weight: bold;">function</span> <span style="color: #bc6ec5; font-weight: bold;">printMillis</span><span style="color: #4f97d7;">()</span> <span style="color: #4f97d7;">{</span>
  <span style="color: #4f97d7; font-weight: bold;">var</span> <span style="color: #7590db;">delta</span> = Date.now<span style="color: #bc6ec5;">()</span> - lastTime
  el.innerHTML = delta
  lastTime = Date.now<span style="color: #bc6ec5;">()</span>
  window.requestAnimationFrame<span style="color: #bc6ec5;">(</span>printMillis<span style="color: #bc6ec5;">)</span>
<span style="color: #4f97d7;">}</span>

window.requestAnimationFrame<span style="color: #4f97d7;">(</span>printMillis<span style="color: #4f97d7;">)</span>
</pre>
</div>

<script type="text/javascript">
</script>

<script type="text/javascript">
var lastTime = Date.now()
var el = document.querySelector('[data-id="millisecond-monitor"]')
function printMillis() {
  var delta = Date.now() - lastTime
  el.innerHTML = delta
  lastTime = Date.now()
  window.requestAnimationFrame(printMillis)
}

window.requestAnimationFrame(printMillis)</script>
</div>
</div>

<div id="outline-container-org1042b3e" class="outline-4">
<h4 id="org1042b3e"><span class="section-number-4">4.1.4</span> the solution</h4>
<div class="outline-text-4" id="text-4-1-4">
<p>
So how do games not stutter every time your browser takes a bunch of time to
inefficiently render a gif you're not even looking at because you're playing a
game? Games multiply a time delta.
</p>

<p>
Take this psuedo-code as an example:
</p>

<pre class="example">
if player1HoldingRight
  player1Position.x = player1Position.x + player1Speed
</pre>

<p>
Here <code>player1Speed</code> is a simple fixed number. The speed is tuned to you playing
the game at 30 FPS. The new <code>x</code> is the old <code>x</code> plus that speed. Simple! But a
lie. To get around it, we use the delta since our last frame.
</p>

<pre class="example">
if player1HoldingRight
  player1Position.x = player1Position.x + (player1Speed * timeSinceLastTick)
</pre>

<p>
Sometimes we call this a tick. Here we do multiplication. If the delta was high,
then the amount we move the player is high. If it's low, the amount we move the
player is low. Mathematically it scales perfectly. There's some complications
with this approach, but rest assured <span class="underline">this is what everyone uses today</span>. Unity
games are no exception.
</p>

<p>
Here's an example of the timing scaling to your machine's speed:
</p>

<iframe src="https://www.winningsolitaire.com"></iframe>
</div>
</div>

<div id="outline-container-org9a34184" class="outline-4">
<h4 id="org9a34184"><span class="section-number-4">4.1.5</span> side by side</h4>
<div class="outline-text-4" id="text-4-1-5">
<p>
I managed to get my hands on the up-until-now rumored purple queen sprites.
Many berry runners died to bring us this sprite from KQ 4 Turbo X
Championship Legendary Edition. You can see the queens moving horizontally
in separate "swim lanes". We have exaggerated artificial delays we're adding
to demonstrate how the varied methods work.
</p>

<div data-id="swim-lanes" style="width: 100%; height: 28em;">
  <div style="position: absolute;">Rough delay per frame graph</div>
  <canvas data-id="speed-graph" style="display: block;" width="0px" height="0px">
    Speed canvas
  </canvas>
  <div style="position: absolute;">Fixed frame (tick)</div>
  <canvas data-id="fixed-tick" style="display: block;" width="0px" height="0px">
    Fixed tick canvas
  </canvas>
  <div style="position: absolute;">Variable frame (tick)</div>
  <canvas data-id="variable-tick" style="display: block;" width="0px" height="0px">
    Variable tick canvas
  </canvas>
  <div style="position: absolute;">Ideal variable frame (tick)</div>
  <canvas data-id="ideal-variable-tick" style="display: block;" width="0px" height="0px">
    Ideal variable tick canvas
  </canvas>
</div>

<script type="text/javascript">
'use strict'

function initSwimLane(container, canvas) {
  canvas.height = container.clientHeight / 4
  canvas.width = container.clientWidth
  return canvas
}
var container = document.querySelector('[data-id="swim-lanes"]')
var speedGraphCanvas = initSwimLane(
  container,
  document.querySelector('[data-id="speed-graph"]')
)
var fixedTickCanvas = initSwimLane(
  container,
  document.querySelector('[data-id="fixed-tick"]')
)
var variableTickCanvas = initSwimLane(
  container,
  document.querySelector('[data-id="variable-tick"]')
)

var idealVariableTickCanvas = initSwimLane(
  container,
  document.querySelector('[data-id="ideal-variable-tick"]')
)

// Shamelessly lifted from https://gist.github.com/gre/1650294
function easeQuad (t) { return t<.5 ? 2*t*t : -1+(4-2*t)*t }
var lastTick = new Date()

function withinSpeedDip(width, x) {
  return x > width - (width * 0.66) && x < width - (width * 0.33)
}

function calcDelay(width, x) {
  if(withinSpeedDip(width, x)) {
    var percent = (x - (width * 0.33)) / (width * 0.33)
    var delay = easeQuad(percent * 1.8) * 100
    return delay + 33
  }
  else {
    return 33 // standard fixed delay
  }
}

function plotSpeedGraph(canvas) {
  var height = canvas.height
  var width = canvas.width
  var context = canvas.getContext('2d')
  context.beginPath()
  context.strokeStyle = 'lightgreen'
  context.lineWidth = 3
  const lineHeight = height * 0.75
  context.moveTo(0, lineHeight)
  context.lineTo(width * 0.33, lineHeight)
  context.quadraticCurveTo(width * 0.5, -height * 0.5, width * 0.66, lineHeight)
  context.lineTo(width, lineHeight)
  context.stroke()
}

var reset = [ false, false, false ]

setInterval(function() {
  reset = [ true, true, true ]
}, 5 * 1000)

function startFixed(img) {
  var speed = fixedTickCanvas.width * 0.01
  tickWithDelay(
    0,
    drawQueen,
    function() { return speed },
    img,
    fixedTickCanvas,
    0,
    0
  )
}

function startVariable(img) {
  var speed = variableTickCanvas.width * 0.0003
  tickWithDelay(
    1,
    drawQueen,
    function(delay) {
      var offset = speed * delay
      if(offset < 0) {
        console.log('unexpected offset', offset)
      }
      // Use this as a debounce because we get negative numbers sometimes.
      return offset > 0 ? offset : -offset
    },
    img,
    variableTickCanvas,
    0,
    0
  )
}

function startIdealVariable(img) {
  var speed = idealVariableTickCanvas.width * 0.0003
  tickWithoutDelay(
    2,
    drawQueen,
    function(delay) {
      return speed * delay
    },
    img,
    idealVariableTickCanvas,
    0,
    0
  )
}

function loadQueen() {
  var img = new Image()
  img.addEventListener('load', function() {
    startFixed(img)
    startVariable(img)
    startIdealVariable(img)
  }, false)
  img.src = 'assets/kq-purple-queen-float-forward-01.png'
}

function tickSpeedGraph() {
}

function drawQueen(idx, speedFn, img, canvas, delay, x) {
  var height = canvas.height
  var width = canvas.width
  var heightOffset = img.height / 2
  var context = canvas.getContext('2d')
  context.clearRect(0, 0, width, height)
  x += speedFn(delay)
  // TODO: Use .all or similar.
  if (reset[0] || reset[1] || reset[2]) {
    reset[idx] = false
    x = 0
  }
  context.drawImage(img, x, heightOffset)
  context.stroke()

  return x
}

function tickWithoutDelay(idx, tickFn, speedFn, img, canvas, x) {
  setTimeout(function() {
    var newX = tickFn(idx, speedFn, img, canvas, 33, x)
    tickWithoutDelay(idx, tickFn, speedFn, img, canvas, newX)
  }, 33)
}

function tickWithDelay(idx, tickFn, speedFn, img, canvas, delay, x) {
  var newDelay = calcDelay(canvas.width, x + img.width / 2)
  setTimeout(function() {
    var newX = tickFn(idx, speedFn, img, canvas, delay, x)
    tickWithDelay(idx, tickFn, speedFn, img, canvas, newDelay, newX)
  }, delay)
}

plotSpeedGraph(speedGraphCanvas)

loadQueen()</script>
</div>
</div>

<div id="outline-container-orga7f2857" class="outline-4">
<h4 id="orga7f2857"><span class="section-number-4">4.1.6</span> conclusion</h4>
<div class="outline-text-4" id="text-4-1-6">
<p>
We cannot assume all frames are created equal. Frames are not fixed slices of
time but instead highly varied slices of time.
</p>
</div>
</div>
</div>

<div id="outline-container-orga89e505" class="outline-3">
<h3 id="orga89e505"><span class="section-number-3">4.2</span> pixels</h3>
<div class="outline-text-3" id="text-4-2">
</div>
<div id="outline-container-org34ae578" class="outline-4">
<h4 id="org34ae578"><span class="section-number-4">4.2.1</span> 2D as 3D</h4>
<div class="outline-text-4" id="text-4-2-1">
<p>
Display sizes vary all over the place. The result is game engines don't use
pixels directly anymore. Even 2D games are rendered using 3D libraries. In
Unity's case 2D things will be rectangles that face the camera. The coordinate
system Unity uses is arbitrary. You could change the size of your camera and be
able to see further, for example. All of the coordinates used in Unity are
floating point numbers. Floating point numbers are the poor man's numbers that
allow for decimals. Floating point numbers are "lossy", meaning they aren't
exact and even though it might look like the numbers are correct they actually
aren't the same thing. This doesn't mean Unity is doing anything poorly. The
world of 3D gaming is dominated by floating point numbers. The only things that
become hard with floating point numbers are when you want to do exact
comparisons and a large scaling distance.
</p>
</div>
</div>

<div id="outline-container-orgdf1bc1f" class="outline-4">
<h4 id="orgdf1bc1f"><span class="section-number-4">4.2.2</span> what about the pixel graphics?</h4>
<div class="outline-text-4" id="text-4-2-2">
<p>
Generally what happens with pixel graphics is someone will build the images
using fixed pixels, and then assign that image to a rectangle that'll show up on
the screen. Most of the time there's a filter applied to the images in real-time
that blurs and distorts the image. You want this in a vast majority of 3D games,
as it addresses graininess and a number of other visual artifacts. In the case
of retro graphics games, the filter is disabled so you see the raw pixels. They
are still stretched though.
</p>
</div>
</div>

<div id="outline-container-org13f2af8" class="outline-4">
<h4 id="org13f2af8"><span class="section-number-4">4.2.3</span> <span class="todo TODO">TODO</span> conclusion</h4>
</div>
</div>

<div id="outline-container-orgb633347" class="outline-3">
<h3 id="orgb633347"><span class="section-number-3">4.3</span> <span class="todo TODO">TODO</span> the wrap glitch</h3>
</div>

<div id="outline-container-orgae40a0b" class="outline-3">
<h3 id="orgae40a0b"><span class="section-number-3">4.4</span> <span class="todo TODO">TODO</span> game stutter</h3>
</div>

<div id="outline-container-org4e2ab6d" class="outline-3">
<h3 id="org4e2ab6d"><span class="section-number-3">4.5</span> <span class="todo TODO">TODO</span> the "drip"</h3>
</div>
</div>
